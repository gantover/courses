
\documentclass{report}

%%% Imports %%%
\usepackage[utf8]{inputenc}
\usepackage{palatino}
\usepackage{float}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage[a4paper, total={6in,10in}]{geometry}
\usepackage{blindtext}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{empheq}
\usepackage{mdframed}
\usepackage{booktabs}
\usepackage{color}
\usepackage{psfrag}
\usepackage{bm}
\usepackage{tcolorbox}
\usepackage{bookmark}
\usepackage{tikz}
\newcommand{\warning}{
	{\fontencoding{U}\fontfamily{futs}\selectfont\char 66\relax}
}
\setlength{\parindent}{0em}
\usepackage{silence}
%Disable all warnings issued by latex starting with "You have..."
\WarningFilter{latex}{You have requested package}
%Code listing env
\usepackage{listings}
\usepackage{rust_latex/listings-rust}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
		backgroundcolor=\color{backcolour},   
		commentstyle=\color{codegreen},
		keywordstyle=\color{magenta},
		numberstyle=\tiny\color{codegray},
		stringstyle=\color{codepurple},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstset{style=mystyle}

%%% Inkscape Integration %%%
\usepackage{import}
\usepackage{pdfpages}
\usepackage{transparent}
\usepackage{xcolor}

\newcommand{\incfig}[2][1]{%
		\def\svgwidth{#1\columnwidth}
		\import{./figures/}{#2.pdf_tex}
}

\pdfsuppresswarningpagegroup=1

%%% Define colors %%%%
\definecolor{Green}{rgb}{0.2,0.9,0.2}

%%% Title and author %%%
\author{Damian Hubert}
\title{Rust}

%%% Main Document Space %%%
\begin{document}

\maketitle
\tableofcontents



\chapter{Fondamentals}


\section{Cargo}
\begin{itemize}
	\item Package manager, Build system, Test runner, Docs generator
\end{itemize}

\begin{tcolorbox}[title=Creating Project,colback=backcolour]
\begin{lstlisting}[language=bash]
cargo new "app name"
\end{lstlisting}
\end{tcolorbox}

\begin{itemize}
	\item \textbf{Cargo.toml} is the config file for the project
		\begin{itemize}
			\item \textbf{name} is independent of the directory name 
			\item \textbf{version} uses semantic versioning, see \href{https://semver.org}{this link} 
			\item \textbf{authors} should be completed by itself using git credentials 
		\end{itemize}
	\item \textbf{src} subdirecory with \textbf{main.rs} 
\end{itemize}

\begin{tcolorbox}[title=Running a Program,colback=backcolour]
\begin{lstlisting}[language=bash]
cargo run
\end{lstlisting}
\end{tcolorbox}

Target directory
\begin{itemize}
	\item Where cargo outputs all its build artefacts 
	\item \textbf{To add in .gitignore} 
\end{itemize}

By default, cargo compiles the project with debug symbols by default
\begin{tcolorbox}[title=Disable Debug Symbols,colback=backcolour]
\begin{lstlisting}[language=bash]
cargo run --release
# will be a lot faster
\end{lstlisting}
\end{tcolorbox}


\section{Variables}

\subsection{Default}

\begin{tcolorbox}[title=Structure,colback=backcolour]
\begin{lstlisting}[language=rust]
fn main() {
	let whatever = 2;
	// auto
	let whatever: i32 = 2;
	// specific type
}
\end{lstlisting}
\end{tcolorbox}

\begin{itemize}
	\item \textbf{let} declares a variable 
	\item Rust is a stongly typed language
		\begin{itemize}
			\item By default it will be \textbf{auto} 
			\item But a \textbf{specific} type can be specified
		\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textbf{let} statements can also initialize multiple variables at once, it can de-structure the data
\end{itemize}

\begin{tcolorbox}[title=Deconstruction Example,colback=backcolour]
\begin{lstlisting}[language=rust]
fn main() {
	let (hello, world) = (8, 50);
}
\end{lstlisting}
\end{tcolorbox}

\subsection{Immutability}

\begin{itemize}
	\item By default, variables are \textbf{immutable} 
		\begin{itemize}
			\item \textbf{To make it mutable} add \textbf{mut} after let
		\end{itemize}
\end{itemize}

\subsection{Constants}

\begin{itemize}
	\item \textbf{const} instead of let
		\begin{itemize}
			\item The \textbf{convention} is to use SCREAMING\_NAMES 
			\item The type annotation is \textbf{required} here !
		\end{itemize}
	\item \textbf{Two reasons} to use const
		\begin{enumerate}
			\item A const is \textbf{global}  
			\item They're really \textbf{fast} at compile time
		\end{enumerate}
\end{itemize}


\section{Scope}

\begin{itemize}
	\item The scope is the place in the code where we are allowed to use the variables 
	\item The scope of variable is contained inside its block, and sub-blocks. If a block ends : the variable is \textbf{immediatly} dropped. 
	\item Variables can be \textbf{shadowed}, they're always \textbf{local to their scope}  
\end{itemize}

\begin{tcolorbox}[title=Shadowing,colback=backcolour]
\begin{lstlisting}[language=rust]
fn main() {
	let x = 5;
	{
		let x = 99;
		println!("{}", x); // prints 99
	}
	println!("{}", x); // print 5
}
\end{lstlisting}
\end{tcolorbox}

\begin{tcolorbox}[title=Shadowing in the same scope,colback=backcolour]
\begin{lstlisting}[language=rust]
let mut x = 5;
let x = x; // is now immutable
// can also be done to modify the type of the variable
\end{lstlisting}
\end{tcolorbox}

\section{Memory Safety}
\begin{itemize}
	\item Variables must be initialized to a value before compiling 
	\item The compiler must be sure that the variable will have a value assigned to it
\end{itemize}


\section{Functions}

\begin{itemize}
	\item Naming convention : \textbf{sneak\_cases}
\end{itemize}

\begin{tcolorbox}[title=Functions doesn't have to appear before we call them,colback=backcolour]
\begin{lstlisting}[language=rust]
fn main() {
	do_stuff();
}
fn do_stuff() {
}
// is valid !
\end{lstlisting}
\end{tcolorbox}

\begin{itemize}
	\item Functions \textbf{parameters} are defined with \textbf{(name: type, other variables)} 
	\item Specify the return type by adding \textbf{-> type}  
\end{itemize}

\begin{tcolorbox}[colback=backcolour]
\begin{lstlisting}[language=rust]
fn do_stuff(qty: f64, oz: f64) -> f64 {
	return qty * oz;
	// The short hand for returning values is to leave the ";" off
	qty * oz
}
\end{lstlisting}
\end{tcolorbox}

\begin{itemize}
	\item Leaving the ";" off the last expression in a block, will make it be returned as the value of the block
	\item There isn't support for named arguments, so all the values must be provided in the \textbf{correct order}
	\item A single function doesn't support variable numbers of arguments or $\not =$ for the same arguments
		\begin{itemize} 
			\item But macro such as \textbf{println!} do ! 
			\item The name of a macro always end with a "!"
		\end{itemize}
\end{itemize}





\end{document}
